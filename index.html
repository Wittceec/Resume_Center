<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Center Topology Resume</title>
    
    <!-- Tailwind CSS for UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Roboto Mono for a terminal-like feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #0a0a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .info-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background-color: rgba(10, 25, 47, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid #38bdf8;
            border-radius: 0.75rem;
            padding: 2rem;
            z-index: 10;
            visibility: hidden;
            opacity: 0;
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.3);
            transition: opacity 0.5s, visibility 0.5s;
        }
        
        .exit-button {
            position: absolute;
            top: 0.5rem;
            right: 0.75rem;
            font-size: 1.5rem;
            color: #f87171;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: color 0.3s;
        }
        .exit-button:hover {
            color: #ef4444;
        }

        #reset-view-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background-color: rgba(56, 189, 248, 0.8);
            color: #0a0a1a;
            border: 1px solid #38bdf8;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        #reset-view-button:hover {
             background-color: #7dd3fc;
            box-shadow: 0 0 15px #7dd3fc;
        }
    </style>
</head>
<body>

    <canvas id="bg-canvas"></canvas>

    <!-- UI Panels for each section -->
    <div id="panel-about" class="info-panel">
        <button class="exit-button">[x]</button>
        <h2 class="text-2xl font-bold text-cyan-400 mb-4">// Node: Workstation (About Me)</h2>
        <p>This workstation represents my core skills and background. I am a network and Linux enthusiast with a deep passion for understanding how systems communicate and operate.</p>
    </div>

    <div id="panel-experience" class="info-panel">
        <button class="exit-button">[x]</button>
        <h2 class="text-2xl font-bold text-cyan-400 mb-4">// Node: Router (Experience)</h2>
        <p>This router symbolizes my professional experience, directing traffic and making connections. As a Network Administrator, I've managed extensive server networks and implemented robust security protocols.</p>
    </div>

    <div id="panel-projects" class="info-panel">
        <button class="exit-button">[x]</button>
        <h2 class="text-2xl font-bold text-cyan-400 mb-4">// Node: Server (Projects)</h2>
        <p>This server hosts my key projects, such as a home lab network built with pfSense and Proxmox, showcasing my hands-on skills in virtualization and network services.</p>
        <a href="#" class="text-cyan-400 hover:underline mt-2 inline-block">View on GitHub &rarr;</a>
    </div>

    <div id="panel-contact" class="info-panel text-center">
        <button class="exit-button">[x]</button>
        <h2 class="text-2xl font-bold text-cyan-400 mb-4">// Node: The Cloud (Contact)</h2>
        <p>This cloud represents my connection to the wider world. Let's connect.</p>
        <p class="text-lg text-white mt-4">your.email@example.com</p>
    </div>
    
    <button id="reset-view-button">[ Reset View ]</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a1a);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const initialCameraPosition = new THREE.Vector3(0, 50, 35);
        camera.position.copy(initialCameraPosition);
        camera.lookAt(0, 0, 0);

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x1f2937, 2.0);
        scene.add(hemisphereLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(20, 30, 20);
        scene.add(dirLight);

        // --- ENVIRONMENT ---
        const floorGeo = new THREE.PlaneGeometry(80, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a202c, metalness: 0.9, roughness: 0.4 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        
        const grid = new THREE.GridHelper(200, 40, 0x0e7490, 0x0e7490);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // --- DEVICE MODELS & POSITIONS ---
        const sections = ["contact", "experience", "projects", "about"];
        const nodePositions = {
            contact: new THREE.Vector3(0, 5, 25),
            experience: new THREE.Vector3(0, 2, 5),
            switch: new THREE.Vector3(0, 1, -10),
            projects: new THREE.Vector3(20, 4, -25),
            about: new THREE.Vector3(-20, 2, -25),
        };
        
        const clickableGroups = [];
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.6, metalness: 0.2 });
        const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x38bdf8, roughness: 0.5, metalness: 0.8, emissive: 0x38bdf8, emissiveIntensity: 0.1 });
        const hoverMaterial = new THREE.MeshStandardMaterial({ color: 0x7dd3fc, emissive: 0x7dd3fc, emissiveIntensity: 0.6, toneMapped: false });
        
        // Functions to create device models
        function createCloud() {
            const group = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.7, roughness: 0.8, emissive: 0x38bdf8, emissiveIntensity: 0.2 });
            for(let i=0; i<6; i++) {
                const sphere = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * 2.5 + 2, 8, 8), cloudMaterial);
                sphere.position.set((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 4);
                group.add(sphere);
            }
            return group;
        }
        function createRouter() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 3), accentMaterial);
            group.add(body);
            return group;
        }
        function createSwitch() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 4), baseMaterial);
            group.add(body);
            return group;
        }
        function createServer() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 2.5), accentMaterial);
            group.add(body);
            return group;
        }
        function createWorkstation() {
            const group = new THREE.Group();
            const monitorBody = new THREE.Mesh(new THREE.BoxGeometry(6, 3.5, 0.3), accentMaterial);
            monitorBody.position.y = 1.75;
            group.add(monitorBody);
            return group;
        }
        
        // Create and place models
        const modelCreators = {
            contact: createCloud,
            experience: createRouter,
            projects: createServer,
            about: createWorkstation
        };
        
        for (const key in modelCreators) {
            const modelGroup = modelCreators[key]();
            modelGroup.position.copy(nodePositions[key]);
            modelGroup.userData = { name: key };
            modelGroup.children.forEach(child => {
                child.userData.originalMaterial = child.material;
            });
            scene.add(modelGroup);
            clickableGroups.push(modelGroup);
        }

        const switchModel = createSwitch();
        switchModel.position.copy(nodePositions.switch);
        scene.add(switchModel);

        // --- CABLING ---
        const cableMaterial = new THREE.MeshBasicMaterial({ color: 0x0e7490 });
        const connections = [
            [nodePositions.contact, nodePositions.experience],
            [nodePositions.experience, nodePositions.switch],
            [nodePositions.switch, nodePositions.projects],
            [nodePositions.switch, nodePositions.about]
        ];
        connections.forEach(points => {
            const curve = new THREE.CatmullRomCurve3(points);
            const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.2, 8), cableMaterial);
            scene.add(tube);
        });

        // --- INTERACTION ---
        let currentAnimation;
        let activeNode = null;

        function navigateToNode(targetObject) {
            if (activeNode === targetObject) return;
            activeNode = targetObject;
            const targetPosition = new THREE.Vector3();
            targetObject.getWorldPosition(targetPosition);
            const finalPosition = new THREE.Vector3(targetPosition.x, targetPosition.y + 8, targetPosition.z + 15);

            if (currentAnimation) currentAnimation.kill();
            currentAnimation = gsap.to(camera.position, {
                x: finalPosition.x, y: finalPosition.y, z: finalPosition.z,
                duration: 1.5, ease: "power3.inOut"
            });
            showPanel(`#panel-${targetObject.userData.name}`);
        }

        function returnToMapView() {
            if (currentAnimation) currentAnimation.kill();
            activeNode = null;
            currentAnimation = gsap.to(camera.position, {
                x: initialCameraPosition.x, y: initialCameraPosition.y, z: initialCameraPosition.z,
                duration: 1.5, ease: "power3.inOut"
            });
            gsap.to(".info-panel", { opacity: 0, visibility: 'hidden', duration: 0.5 });
        }

        function showPanel(panelId) {
            gsap.to(".info-panel", { opacity: 0, visibility: 'hidden', duration: 0.5 });
            gsap.to(panelId, { opacity: 1, visibility: 'visible', duration: 0.5, delay: 0.8 });
        }
        
        window.addEventListener('click', (event) => {
            if (event.target.closest('.info-panel')) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableGroups, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while(obj.parent && !obj.userData.name) {
                    obj = obj.parent;
                }
                navigateToNode(obj);
            }
        });
        
        document.querySelectorAll('.exit-button, #reset-view-button').forEach(button => {
            button.addEventListener('click', returnToMapView);
        });

        let hoveredObject = null;
        window.addEventListener('mousemove', () => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableGroups, true);

            const intersectedNode = (intersects.length > 0) ? intersects[0].object.parent : null;

            if (hoveredObject && hoveredObject !== intersectedNode) {
                gsap.to(hoveredObject.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                hoveredObject.children.forEach(child => { if(child.isMesh) child.material = child.userData.originalMaterial; });
                hoveredObject = null;
            }

            if (intersectedNode && !hoveredObject) {
                hoveredObject = intersectedNode;
                gsap.to(hoveredObject.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.3 });
                hoveredObject.children.forEach(child => { if(child.isMesh) child.material = hoverMaterial; });
            }
            document.body.style.cursor = intersectedNode ? 'pointer' : 'default';
        });
        
        // --- RENDER LOOP ---
        const targetLookAt = new THREE.Vector3(0, 5, 0);
        function animate() {
            requestAnimationFrame(animate);
            let lookAtTarget = new THREE.Vector3(0, 5, 0); 
            if (activeNode) {
                 lookAtTarget = activeNode.position;
            }
            targetLookAt.lerp(lookAtTarget, 0.05);
            camera.lookAt(targetLookAt);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
